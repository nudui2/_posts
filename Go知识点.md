---
title: GO知识点
date: 2017-05-09 18:41:06
tags: 闫帅
---
运行性能、开发效率及维护难度是大部分程序通常考虑的三个点。

静态类型语言：拥有编译检查；动态语言：拥有包扩展、弱类型如var。

######Go的优势
* 开发速度更快
* 天生支持并发性，有效利用多核且执行性能良好
* 没有过多的依赖，因此部署及维护方便
* 结合静态语言的安全性和高效性（强类型语言、编译检查），同时具备动态语言的易开发性

######Go的缺点
* goroutine切换不受程序控制
* GC延迟有待改善
* 生成的二进制文件体积是比较大，都包含了运行环境runtime
* 不支持函数重载，也不支持继承，而采用接口来实现多态。
* 不支持泛型
* 不支持静态变量

######Go中的runtime
类似于java中虚拟机，主要负责内存分配、垃圾回收、线程、切片、反射等处理。
######cgo的使用
- 作用是允许在Go中使用C的库。
- 使用cgo的方式是import “C”。C的库可以通过注释的方式引入。
- C和Go的类型在交互时需要强制转换。字符串转换是C.CString(s)和C.GoString(cs)
- C变量分配的内存需要手动管理：**defer C.free(unsafe.Pointer(Cvariable))**

######SWIG的了解
一个封装器或者说生成器，使C/C++代码能够嵌入到目标语言中，并提供可调用的接口。
在Go中可以通过cgo来调用SWIG封装的C++代码。
######go build、go install 和 go run 的区别
- go build 编译包，如果是main包则在当前目录生成可执行文件，其他包不会生成.a文件；
- go install 编译包，同时复制结果到$GOPATH/bin，$GOPATH/pkg等对应目录下；
- go run gofiles... 编译列出的文件，并生成可执行文件然后执行。注意只能用于main包，否则会出现go run: cannot run non-main package的错误。
- go run是不需要设置$GOPATH的，但go build和go install必须设置。go run常用来测试一些功能，这些代码一般不包含在最终的项目中。

######公有和私有
- 公有性以大写字母开头；
- 私有性以小写字母开头。

######GOPATH
- GOPATH默认和GOROOT相同，但具体的项目可以修改GOPATH，GOPATH可以设置多个值，安装第三方包的位置是在GOPATH的第一个项目路径下。
- 查看当前GOPATH值：**go env GOPATH**

######iota
iota是golang语言的常量计数器,只能在常量的表达式中使用。const中每新增一行，iota计数一次。常用于枚举。

######go支持 并行或同时 赋值
a,b = b,a 省去了交换函数。

###### “_”是空变量：可用于抛弃或跳过某些值
- 函数返回多个值时，有些不需要可以用"_"抛弃。
- 枚举中跳过某些值。

######Unicode和UTF-8
ASCII是单字节字符，unicode自然就是多字节字符了，可以表示的范围更广了，包括中文。
UTF-8是集大成者，明显的特征就是可变长方式。unicode采用16进制数表示，UTF-8采用二进制数表示。

######defer
推迟作用在函数即将返回时才调用，可以用来释放资源或者用于函数的调试追踪。

######数组长度最大为 2Gb
**[]int**和**[5]int**是两种类型，实际上前一种已经变成了切片(即没有指定个数的数组声明实际上是一个切片)。数组作为参数有两种形式

- 传递数组的指针（不常用）
- 使用数组的切片

######闭包
匿名函数，可以访问局部变量，且不随函数结束而释放。
######切片
- 是数组一个片段的引用，且长度可以在运行时修改。
- 最大长度也叫切片的容量是从最小索引起算（相关数组的长度-起始索引），用cap函数计算。
- 一个数组可以有多个切片，这些切片之间共享相同的数组内存。
- 未初始化之前默认为 nil，长度为 0。
- 切片只能向后移动，不能被重新分片以获取数组的前一个元素，但是长度可扩充。由s[2:5]扩增到s[0:4]，长度增长，但起始位置不变，仍然从arr[2]开始。

	**生成切片的两种方式：**

	- make([]int, 50, 100)
	- new([100]int)[0:50]

######new() 和 make() 的区别
都在堆上分配内存，但适用于不同的类型。new适用于值类型，返回的是一个指针；而make适用于引用类型(切片、map 和 channel)，返回的是一个初始值。
###### map字典
初始化和注意事项：

- map[string]int{"one": 1, "two": 2}
- make(map[string]float32)
- 不要用new来创建map，否则只会创建一个空引用的指针，运行时出错。
- 非线程安全的
- 删除一个键delete(map1, key1)
- 并不是所有变量都是可寻址的，像Map的值元素就是不可寻址的。即不能***直接***调用元素的方法m["x"].Func()错误，但如果元素是指针的话，则可以。

###### 结构体 struct
如果struct结构体的所有字段都能够使用==操作比较，那么结构体变量也能够使用==比较。 但是，如果struct字段不能使用==比较，那么结构体变量使用==比较会导致编译错误。array同理。
###### 互斥锁：sync.Mutex
守护在临界区入口来确保同一时间只能有一个线程进入临界区。

```
type SyncedBuffer struct {
	lock 	sync.Mutex
	buffer  bytes.Buffer
}
```
###### 继承
通过匿名内嵌（结构体或接口）来实现继承的机制（更像是组合的方式）。

- 重载：外层名字会覆盖内层名字（但是两者的内存空间都保留）。
- 相同的名字在同一级别出现了两次，将会引发一个错误（不使用没关系）。

继承的好处：复用和多态。在Go中通过组件编程的思想来实现这两点。
- 代码复用通过组合和委托实现
- 多态通过接口的使用来实现

###### 方法
- Go 方法是作用在接收者（receiver）上的一个函数，一种特殊类型的函数。
- 类型和作用在它上面定义的方法必须在同一个包里定义，否则会报错。可以通过别名来扩展。

###### 函数和方法的区别
- 函数将变量作为参数;方法在变量上被调用
- 方法需要指定接受者的类型，如果制定了变量名字，则变量必须在方法内使用。
- 方法要和接受者类型在同一个包中声明

###### 接口
**接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。**

空接口由类型和值组成。

一个接口变量是一个多字（multiword）数据结构，默认值是 nil。本质上是一个指针（不完全是），第一部分存储具体的对象，第二个部分是一个方法指针表，表中每一项都是一个指针，指向一个具体实现了的方法。这就模拟了多态的实现。
- 不需要显式声明它实现了某个接口，只要实现了接口中的方法，就是实现了接口。
- 跨包实现接口是允许的。
- 需要注意，谁实现了接口的方法中取决于receiver的类型，指针类型和值类型是不同的。
- 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址。
- 接口类型本身也是指针。

###### 断言
- 只有接口类型变量才能适用类型断言：var.(T)
- var.(T)类型断言失败时会返回T类型的“0值”，而不是变量原始值。

###### 可以用 type-switch 进行运行时类型分析，但是在 type-switch 不允许有 fallthrough
###### 反射
可以动态的获取类型的信息，如获取变量的类型和值。

- reflect.TypeOf：返回上层类型
- reflect.ValueOf：返回值
- value.Type()：返回上层类型
- value.Kind()：返回底层类型
- value.NumField()：如果是结构体，返回字段的数量
- value.Field(i)：返回字段的值
- value.Method(0).Call(nil)：返回第一个方法（idx=0）
- reflect.ValueOf(&t).Elem()：如果值不可修改，可通过指针并调用Elem变为可修改的。

###### 函数重载
可以用可变参数 ...T 作为函数最后一个参数来实现（T为空接口）。
###### 结构体的特性
###### 一个厉害的特性：高阶函数
函数可以作为其他函数的参数或返回值，因此可以用参数中的函数对其他参数做操作（其他参数又可以用可变参数）。
###### 如何理解Go中的面向对象
Go没有类，任何类型都可以理解为一个类，因为类型可以灵活地扩充方法，也可以通过接口实现多态。

- 封装：通过包内标识符可见性来封装，首字母大写可导出，对外可见。
- 继承：用组合实现，即内嵌一个或多个复合类型（如结构体或接口）。
- 多态：用接口实现，且接口是松耦合的，随时扩充，随时实现接口。

###### 文件读写
os包、io包、bufio包。

判断是否读取到文件末尾：error == io.EOF
- 1.inputFile := os.Open(filename) 打开文件
- 2.inputReader := bufio.NewReader(inputFile) 创建读取器
- 3.inputReader.ReadString（‘结束字符’） 读取字符串

写入的最后不要忘了buf.Flush()一下。

###### 用 Gob 传输数据
Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式，在 encoding 包中。特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。在编码和解码过程中用到了 Go 的反射。
###### defer-panic-and-recover
错误处理机制，无法预测的错误或允许程序终止的错误。普通的错误只需要在返回值里检查是否为nil即可。

- panic发生后，下面的代码不执行，但defer仍然会执行。
- recover 只能在 defer 修饰的函数中使用。
- panic触发后，先触发最内层函数的defer。
- 只要存在了recover，则panic后就不会直接停掉，而交由自己处理。

###### 退出程序 os.Exit(1)
###### 怎么样做代码测试：单元测试和基准测试
单元测试：以_test结尾的go文件是测试文件，不会被默认编译，除非使用go test命令。测试文件中需要添加以Test开头的测试函数TestAbcde(t *testing.T)。

基准测试：以Benchmark开头的函数。
###### 性能分析
go test调试、pprof包、gopprof工具，这些我有了解过，而且gopprof有很多命令，也比较强大。调试这方面任何一门语言都是比较重要的部分，所以我觉得go也肯定是手段丰富的，必要的话也可以自己写一写工具。
###### 协程goroutine
go中的协程是由协程调度器动态映射到系统线程上执行的，封装了线程的复杂操作，是线程之上的执行单元，比线程更轻量，占用更少的内存，只需要4k的栈内存（在栈上开辟初始化，堆上运行--转移内存到堆上），且内存大小可以动态调整，因此不会溢出。

- runtime.Gosched()让出处理器，然后自动恢复执行。
- 真正的并行需要使用**runtime.GOMAXPROCS(n)**指定允许同时运行的协程数量。但只有一个协程时最好不要设置。

与其他语言中协程的不同：
- 可以真正的支持并行。
- 使用通道来通信。

###### 通道
非缓冲通道的发送和接收是阻塞的：即当前的发送数据没有接收或者接收者等不到发送时就会阻塞在那里。收发是对应的，一发一收，一收才能一发。由此可见非缓冲通道中一次只有一个数据。

- 通道解决了同步的问题(按顺序一个一个的数据传送给不同的协程)，通道的读写具有原子性(<-)。
- 两个协程共享一个通道，那么接收方要等发送方发送我方接收后才会继续下面的代码。
- 使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：
- 管道之间是不依赖，即可以先写接收，然后才写发送，这是因为接收方会阻塞的等待数据。
- 缓冲通道(make的时候设置容量)的好处是发送方不需要等到接收方接收了上一个数据才继续发送，因此缓冲的一个作用是一定程度上避免死锁（只要容量>0）。
- 共用的发送通道要用缓冲，否则可能会阻塞，导致接收方使用之前无法继续存入数据。
- 不能向关闭的通道中写入数据会panic，但可以读取，返回错误标识。

素数过滤的思想：除2通道过滤后给除3通道，然后4、5...

```
使用锁的情景：

* 访问共享数据结构中的缓存信息
* 保存应用程序上下文和状态信息数据

使用通道的情景：

* 与异步操作的结果进行交互
* 分发任务
* 传递数据所有权
```

###### 选择器select：切换协程
自带随机性，如果case中管道无论是发送还是接收，当条件都满足的时候（发送肯定是都满足的），会随机选择一个通过；如果不满足，就执行default。
###### 计时器（Ticker）
以指定的时间间隔重复的向通道 C（结构体的一个字段） 发送时间值，可以配合select定期的做一些处理。
###### 惰性生成器
用到的时候才计算并生成下一个，而不是一开始就生成很多。


---
### 面试相关
---
###### 介绍一下golang这门语言
- 设计目的：
- 亮点：
	- 安全：不需要程序员直接管理内存，所有的内存都是运行时自行管理。
	- 开发效率高：有动态语言的灵活，编译速度快，而且代码格式化统一。
	- 并发性：天生的并发支持goroutine。
	
- 有哪些不足：
- 自己使用的感受：

###### 不要通过共享内存来通信，而应该通过通信来共享内存，怎么理解？
这里指的是强大的协程和通道channel，通道是类型相关的，且是线程安全的。（回到通道的知识点）
###### 用goroutine模拟生产消费者

```
package main
import "fmt"
import "time"
func Producer (queue chan<- int){
        for i:= 0; i < 10; i++ {
                queue <- i  
                }
}
func Consumer( queue <-chan int){
        for i :=0; i < 10; i++{
                v := <- queue
                fmt.Println("receive:", v)
        }
}
func main(){
        queue := make(chan int, 1)
        go Producer(queue)
        go Consumer(queue)
        time.Sleep(1e9) //让Producer与Consumer完成
}
```
###### Lock()或RLock()的区别？
###### sync.Once.Do()
全局唯一操作，只运行一次，可以用来初始化。
###### defer有哪几种用法
延迟执行：文件的关闭、panic的恢复、闭包后续处理。
###### 什么是逗号ok模式
函数返回两个值，第一个值是函数计算结果，第二个值是判断是否成功的bool值或者具体错误信息(如果正确则为nil)
###### 如何修改字符串中的一个字符？
字符串转为字符切片，修改，然后强转回字符串。

###### 如何获取一个字符串的字节数和字符数？
字节数：`len(str)` 字符数：可以用utf8包的函数或者转成切片计算长度。
###### 如何连接字符串？
- 使用bytes包中的Buffer
- Strings.Join()
- +=

###### 如何使用输入通道和输出通道代替锁？
```
func Worker(in, out chan *Task) {
    for {
        t := <-in
        process(t)
        out <- t
    }
}
```
###### 如何在程序出错时终止程序？
os.Exit(1)或者panic




















































---
title: 技术概念点
date: 2017-05-09 18:41:06
tags: 闫帅
---

###### 反射的实现原理？
反射就是动态获取属性和方法。

- 作用是：动态创建类型实例。
- 原理是：程序在编译的时候生成了元数据表，解析这些信息就实现了反射。

###### 并行与并发
- 并发：一个程序由多个线程执行任务就是并发。
- 并行：同一个程序同时运行在多个处理器上是并行，所以并行利用多核提高速度。

###### 并发可能会带来那些问题：
本质问题就是不同步。
###### 分段栈和连续栈
分段栈的重要意义就在于，栈空间初始分配很小的大小，然后可以随便需要自动地增长栈空间．在多线程环境中就可以开千千万万个线程或协程而不至于耗尽内存。但是，一种很极端的情况就是，某函数的执行的栈大小一直在初始栈大小边界绯徊，那么就会不断地触发分段栈的分配回收操作，可以想象这是多么蛋疼的事情。
连续栈，当发生栈越界之后，就会重将分配一块更大的内存空间作为新的栈，将旧栈拷贝到新栈中。
###### 多路复用技术
###### 虚拟内存
使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
###### 标记-清除算法
###### jvm垃圾收集（标记-清除,复制，标记-整理，分代）算法
###### gcc编译器
早期是指c语言编译器，后期发展后指编译器集合。可以将上层代码编译成机器识别的可执行程序。
###### 编译和解释的区别
编译是运行前将源代码编译成目标代码然后执行；解释是执行时一条条指令编译成机器指令在执行。一个是一次性翻译完，一个是现取现翻译。
###### 哈希
哈希用于将任意长度的数据映射到固定长度的数据。如果不同的主键得到相同的哈希值，则发生了冲突。

- 链地址法（Separate Chaining）：在链地址法中，每个桶（bucket）是相互独立的，每一个索引对应一个元素列表。处理HashMap 的时间就是查找桶的时间（常量）与遍历列表元素的时间之和。
- 开放地址法（Open Addressing）：在开放地址方法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个未被占用的地址。开放地址即某个元素的位置并不永远由其哈希值决定。

###### 哈希表或字典的实现原理
数组和链表的结合。数组中每一个元素都是一个节点，节点内存储着key、value和next指针，寻址时通过一个哈希算法对应到位置索引，如果已存在就往后索引。
###### 常用的正则表达式
###### git和svn的区别
###### 构造&析构顺序
通常情况下先构造的后析构：有静态变量或全局除外（因为他们和程序的生命周期相同）。
###### 位操作
* `^`：异或，取“异”字，不同为1，相同为0
* `~`：取反
* `<<`：左移n位，即乘以2的n次方
* `>>`：带符号右移n位，即除以2的n次方

###### 整数溢出的处理
###### 复数运算法则
###### 随机数的原理
###### cache
介于主存和CPU之间的存储器，相比主存容量很小，但存取速度却接近CPU，主要用来解决CPU和主存之间的速度不匹配的问题，做一个缓冲。
###### MySQL数据库与NoSQL数据库的区别？
###### 虚拟存储
###### 事务四大特性(简称ACID)  
* 原子性：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。 
* 一致性：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。 
* 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 
* 持久性：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。   

###### 大小端：大部分机器都是小端
- 大端：把数值的高位字节放在内存的低位地址上，把数值的地位字节放在内存的高位地址上。
- 小端：把数字的高位字节放在高位的地址上，低位字节放在低位地址上。

###### 位段或位域
有些情况下只需要很少的位即可表示（如开关，只需要1位），这时候用位域指定位数，因此改变了变量本来占用字节的大小，可以节省空间。
###### 内存对齐
主要指地址对齐，方便存取，统一，速度快。 
###### 浮点数的二进制存储
三部分：符号位、指数位、尾数。
###### float和零值比较、bool、int、指针
- if(x > -0.000001 && x < 0.000001)
- if(x)
- if(0 == x)
- if(null == p)

###### 正则表达式
###### 向量的点乘、叉乘以及归一化的意义？ 
- 点乘：计算方向夹角
- 叉乘：计算垂直向量平面的第三向量

###### 动态链接和静态链接的区别
- 动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中找。 而静态链接就是把所有用到的函数全部链接到exe文件中。
- 动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。

###### 什么是指针的释放? 
1 释放该指针指向的内存,只有堆上的内存才需要我们手工释放,栈上不需要. 
2 将该指针重定向为NULL. 

###### 什么是闭包，闭包有什么用?





---
框架相关
---
###### 如何理解面向对象
在现实中，每一个事物都算是一个对象，那面向对象呢就是对现实中的客观事物进行抽象封装成为一个基本单位，然后反映现实中的相关问题以及它们的作用关系。
###### 面向过程
分析出解决问题的步骤，然后用函数按逻辑步骤实现出来。
###### 多线程有什么用？
它的特点就是并发性，可以让多个任务同时执行。如果是单核系统，就会采用时间片轮询的方式执行，多核系统就会充分发挥多个CPU的优势，提升性能。
###### 什么是线程安全
简单理解就是和单线程运行的结果一样，那就说明是安全的。不安全的因素主要是数据操作和数据同步问题，例如线性表、哈希词典之类的通常是非线程安全的。
###### 为什么要使用线程池
避免频繁地创建和销毁线程，达到线程对象的重用，提升性能，也可以灵活控制并发数目。
###### 单例模式的几种方式
- 非线程安全：static变量和获取函数
- 饿汉式：私有变量直接初始化
- 线程安全：一重锁，性能低
- 线程安全：双重锁

	```
	if(NULL == m_instance)  
    {  
        Lock();//借用其它类来实现
        if(NULL == m_instance)  
        {  
            m_instance = new Singleton;  
        }  
        UnLock();  
    }
	```

###### 常用的设计模式理解
- 工厂模式：封装new操作。

###### 堆和栈的区别
- 栈是由系统分配和释放的，而堆是由程序员自己分配的，如果没有垃圾回收机制，则需要自己释放。
- 栈的内存分配通常是连续的，而堆的内存分配是不连续的，碎片化的，因为是链表的结构。
- 栈的分配速度块，而堆通常由new分配的，速度比较慢。

###### static的作用
- static变量存储在静态存储区，且作用于本文件。
- static变量只能初始化一次，且持久化保存上一次操作的结果。
- static修饰函数，函数在内存中只有一份，普通函数在调用中拷贝一份。

###### 引用和指针的区别
- 引用必须被初始化，指针不需要；
- 引用初始化后不能改变，指针可以改变指向的对象；
- 引用不能指向空值，指针可以。

###### extern"C"
允许包含C的代码，并能按C的方式编译C的代码。之所以这样，是因为c不支持函数重载，要保持名字的正确性。
###### 堆栈溢出的原因和解决办法
原因是由于过多的函数调用，返回的地址数据过多溢出，一般在递归中产生。解决办法：改用非递归方式或者使用全局变量、static变量代替局部变量。
###### 空指针和野指针
- 空指针：地址是 0x00000 所以他不指向任何一个地方。
- 野指针：指向垃圾内存的指针。1.指针变量没有被初始化，缺省值是随机的；2.指针被free或者delete之后，没有设置为NULL。

###### android和iOS的通知回调
- android：注册一个回调的接口，然后再注册一个实现了接口的监听器，监听器里里实现了具体的操作，但是执行的时候是由实现了回调接口的对象执行操作。
- iOS：采用的是代理委托机制，一个声明代理，一个实现代理，比较清晰。还有一个block相当于是代理，比较灵活，我通常是局部使用。

###### 结构体和类有何区别？
- 结构体是值类型，而类是引用类型。
- 结构体使用栈存储，类使用堆存储。
- 结构体声明字段的时候是不能给初始值的。
- 结构体成员默认为公有的，且没有保护修饰符，类的成员默认为私有。

###### 面向对象设计的基本原则
- 单一职责：一个类只干一件事或者说只有一个因素能改变它。
- 开闭原则：就是尽量不允许修改，只能扩展。
- 里氏代换：子类可以放到父类的位置上，这也是多态的体现。
- 依赖倒置：抽象的高层模块不要依赖于具体的低层模块。
- 接口隔离：接口要简单，小而精。

###### interface与抽象类之间的不同
- 抽象类是对一类事物的描述，而接口是对某些行为的抽象。
- 抽象类可以有实现的方法，且被子类共享，接口只声明不实现，子类必须实现。
- 抽象类不能多继承，而接口可以。

###### 消息队列
分布式应用之间共享数据的方式之一。通过消息队列，应用程序可独立地执行而不需要等待。
###### 关系型数据库和非关系型数据库的区别




- - -
### *网络编程相关知识点*
- - -
###### linux常用相关命令
- df：显示磁盘分区上的可使用的磁盘空间，默认显示单位为KB。
- top：实时动态地查看系统的整体运行情况。
- netstat：打印Linux中网络系统的状态信息
- 查看进程ps -ef|grep xxx
- 添加用户：useradd shuai
- 修改密码：passwd shuai
- 切换用户：su - shuai（sudo切换到root，5分钟失效；sudo -i没有失效时间）
- 网络配置：ifconfig
- 查找：find path -name "文件名"

###### Http：超文本传输协议
http协议传输的数据是明文的，即没有加密的。因此才有了SSL进行加密，也就是Https传输。
###### Https
传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，进行加密信息的确认，使用的加密算法是：非对称加密，对称加密以及HASH算法。
###### 对称加密、非对称加密、HASH算法
- 对称加密：加密和解密使用相同密钥的加密算法。我所了解的就是DES。
- 非对称加密：需要两个密钥公钥和私钥。一个加密，然后用对应的另一个解密。虽然安全，但速度慢，所以适合少量数据。最流行是RSA公钥加密算法。
- HASH算法：MD5，SHA1，SHA256。（签名算法）

###### MD5加密原理
###### DES加密
###### dns （域名系统）
因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。运行在UDP协议之上。
###### RPC
RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务。一个流行的框架Netty.

- 建立连接TCP。
- 寻址：解决如何连接目标主机ip和端口，以及要调用的方法名称。
- 参数序列化传送。
- 反序列化以及结果返回。

###### HTTP请求信息的3部分
* 请求方法（Get或Post）、请求的目标URI/协议及版本（Http1.1）
* 请求头：包含许多有关的客户端环境和请求正文的有用信息
* 请求正文：通常是一些参数

###### Http请求错误码
- 400：请求语义错误或参数错误
- 401：未验证
- 402：预留
- 403：禁止
- 404：没有找到资源

###### Http请求：Get和Post的区别
- Get方式：不安全，直接将数据简单编码后就放到了URL中，且携带数据量也有限制。
- Post方式：以字节流的形式传送，比较安全，且可传递数据量很大。

###### ICMP
本质可以理解为带差错报告的ip协议。
###### ARP:地址解析协议
arp是将ip地址解析为mac(物理地址)，rarp反过来。
###### Redis的了解
###### TCP和UDP的区别？
- TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接。
- TCP提供可靠的传输（有序，无差错，不丢失，不重复）；UDP提供不可靠的传输。
- TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。
- TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制机制。

###### 多线程同步的几种方式
- 临界区：线程挂起等待，依次访问的方式，只有当前访问的线程结束并离开临界区，后面的线程才能继续访问。
- 互斥所：采用互斥锁的方式将公共资源锁住，谁拿锁了谁开启，结束后把锁给后面的线程。
- 信号量：允许多个线程访问公共资源，但是数量又上线。类似于屋子里人满了，只能出一个进一个。
- 事件：就是通知，事件可以实现优先级。

###### 进程、线程和协程的区别
- 进程：一个运行的应用程序就是一个进程，有自己的内存空间。
- 线程：一个进程由一个或多个线程组成，线程共享进程内存空间。
- 协程：和线程相似，但是切换调度由协程自己控制，而线程由系统控制切换。

###### 进程的三种基本状态
- 就绪
- 执行
- 阻塞

###### 进程间通讯的方式有哪些，各有什么优缺点
- 管道：数据只能单向流动，而且只能在父子进程间流动。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
- 消息队列：消息的链表。
- 共享内存
- 套接字( socket ) ：它可用于不同机器间的进程通信。

###### socket是什么？？
套接字，包含IP和端口，实际上是一个接口，封装底层TCP/IP的操作，对外提供连接的能力。
###### TCP连接建立的时候3次握手和和断开连接的4步(tcp的四层模型)
- 3次握手：通知服务器建立连接、服务器反馈等待确认、连接确认成功
- 4步断开：之所以需要4次，因为数据可能没有发送完，因此要告诉客户端我收到了，但不能结束，需要等待结束通知。

###### 内存池、进程池、线程池
自定义内存池的思想通过这个"池"字表露无疑，应用程序可以通过系统的内存分配调用预先一次性申请适当大小的内存作为一个内存池，之后应用程序自己对内存的分配和释放则可以通过这个内存池来完成。只有当内存池大小需要动态扩展时，才需要再调用系统的内存分配函数，其他时间对内存的一切操作都在应用程序的掌控之中。 应用程序自定义的内存池根据不同的适用场景又有不同的类型。 从线程安全的角度来分，内存池可以分为单线程内存池和多线程内存池。单线程内存池整个生命周期只被一个线程使用，因而不需要考虑互斥访问的问题；多线程内存池有可能被多个线程共享，因此则需要在每次分配和释放内存时加锁。相对而言，单线程内存池性能更高，而多线程内存池适用范围更广。
从内存池可分配内存单元大小来分，可以分为固定内存池和可变内存池。所谓固定内存池是指应用程序每次从内存池中分配出来的内存单元大小事先已经确定，是固定不变的；而可变内存池则每次分配的内存单元大小可以按需变化，应用范围更广，而性能比固定内存池要低。
###### 死锁发生的条件
- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：已经占有一个资源，但又因申请新的资源而阻塞，同时又不是放占有的资源。(要么都占有了才执行，要么就不执行并释放资源)
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：几个进程之间形成一种循环等待资源关系。（编号、优先级等）

###### 各个层的协议
* 物理层：RJ45、CLOCK、IEEE802.3 （中继器、集线器）
* 数据链路：PPP、FR、HDLC、VLAN、MAC （网卡、网桥、交换机）
* 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器、防火墙）
* 传输层：TCP、UDP、SPX
* 会话层：NFS、SQL、NETBIOS、RPC
* 表示层：JPEG、MPEG、ASII
* 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

###### 长连接和短连接
###### 同步机制应该遵循的基本准则
* 空闲让进：临界区处于空闲状态，允许一个请求进入。
* 忙则等待：临界资源正在被访问，因而其他试图进入临界区的进程必须等待。
* 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。
* 让权等待：当进程不能进入自己的临界区时，应立即释放处理机。

###### LRU和LFU
* LFU：最少频率
* LRU：最近最少使用

###### LRU的缓存实现
java中本身就有一个LinkedHashMap已经实现了访问顺序存储，继承后重写移除函数，超过一定数量之后自动移除最不常用的。如果要自己写的话，需要使用双链表和HashMap，所有的缓存通过双链表链接起来，每次使用的项调整到链表的头部，于是靠近头部都是最近使用过的，尾部的节点就是可被淘汰的。
###### 共享内存的使用实现原理
- 共享内存定义：共享内存是最快的可用IPC（进程间通信）形式。它允许多个不相关的进程去访问同一部分逻辑内存。共享内存是由IPC为一个进程创建的一个特殊的地址范围，它将出现在进程的地址空间中。其他进程可以把同一段共享内存段“连接到”它们自己的地址空间里去。所有进程都可以访问共享内存中的地址。如果一个进程向这段共享内存写了数据，所做的改动会立刻被有访问同一段共享内存的其他进程看到。因此共享内存对于数据的传输是非常高效的。
- 共享内存的原理：共享内存是最有用的进程间通信方式之一，也是最快的IPC形式。

###### 什么时候用线程
- 需要频繁创建销毁的优先用线程。
- 需要进行大量计算（消耗很多cpu）的优先使用线程。
- 可能扩展到多机分布（独立性强的）的用进程，多核分布的用线程。

###### HTTP 和 TCP 有什么关系? 
HTTP是应用层协议，TCP是传输层协议。
###### connect会阻塞，怎么解决?
最通常的方法最有效的是加定时器；也可以采用非阻塞模式（设置为非阻塞，返回之后用select检测状态）。
###### const的含义及实现机制
const用来说明所定义的变量是只读的。只读的实现是在编译期间，编译器可能使用常数直接替换掉对此变量的引用。





- - -
### *基本算法思想*
- - -
###### 算法的基本思想
###### 动态规划算法：总是基于上次的结果迭代出来。
把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。
###### A*算法原理
###### 迪杰斯特拉算法查找最短路径
###### 最优二叉树
是指WPL（带权路径长度之和）最小。（16*1+8*2+2*3+3*4=50）
###### 哈夫曼树
###### 什么是素数
大于1的数，满足除了1和自身外不能被其它数整除。

实现思路：

- 以小于他自身一半的数遍历，是否能整除。
- go协程的思路：不能被2整除的数放入检测[被3整除的协程]中，后面以此类推。

###### 快速排序的思想
是一种把问题拆分不断化小的思想。从其中任取一个值，将现有数据划分为左右两个子区间，左边的所有数据都小于右边的，然后对左右两个区间继续递归下去。
##### 计算斐波那契数
使用闭包性能更好，使用惰性生成器就更加绝妙了。
###### 统计每个单词出现的次数
###### 最大公约数和最小公倍数
###### 交换两个数：不能使用中间变量
```
a = a + b
b = a - b
a = a - b
位运算：
a = a ^ b
b = a ^ b
a = a ^ b
```
###### 求一个整数的二进制中1的个数
```
思路一：右移，和整数1比较最后一位，结果为1即有一个。不适用与负数，因为负数右移，左侧补1，会导致数越来越大，进入死循环。
func main() {
	a := 11
	n := 0
	for a > 0 {
		if a&1 == 1 {
			n++
		}
		a = a >> 1
	}
}
	
思路二：和1的左移比较，每次判断一个位置，结果比0大即存在一个1
func main() {
	a := 11
	n := 0
	flag := 1
	for flag > 0 {
		if a&flag > 0 {
			n++
		}
		flag = flag << 1
	}
}
		
思路三：减去1，再和原整数做与运算，会把该整数最右边一个1变成0，有多少个1，就可以进行多少次这样的操作。
func main() {
	a := 11
	n := 0
	for a > 0 {
		n++
		a &= (a - 1)
	}
}
```
##### 文件的交集、并集、差集
[腾讯的一道面试题](http://blog.csdn.net/pegasuswang_/article/details/25206407)
###### 根据入栈判断出栈是否合法
思路：栈有一个很有用的性质，对于出栈序列的每一个元素，出战序列中该元素后面比该元素先入栈的一定按照降序排列。（12345入栈合法的如21435）
###### 判断回文数或回文字符串
直接转成字符串，然后转成字符数组，前后比较即可
###### 查找最长回文字符串
以T[i]，T[i+1]为中心的偶数长度子字符串是回文，T[i]为中心的奇数长度子字符串是否是回文 
###### 扔鸡蛋测试楼层的问题
有点递归的思想：假设最少次数为x，那么第一次就应该在x层扔（通过假设第一次在y层就碎了，那么最坏情况第y-1层开始碎，那么第二个鸡蛋要从第1层一直测试到y-1层即最多次数为1+(y-1)=x，因此得出y=x即从x层开始）。后面就是开始递归了，如果第一个鸡蛋x层没碎，那么下一次肯定是2x，然后测试x->2x之间和第一种情况一样，但由于第一次没碎，占用了一次，所以不是2x，而是x+(x-1)...>=100。
###### 括号匹配检测：栈可以用来做对称检测
使用栈，每当遇到左括号入栈，遇到右括号时，栈顶必须为对应的左括号，然后出栈，最后栈为空。
###### 判断一个数是不是2的n次幂？
即二进制里只有一个1，x&(x-1) == 0。
###### 裴波那契数列：递归实现

```
static int Fn(int n)
        {
            if (n <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
            if (n == 1||n==2)
            {
                return 1;
            }
            return checked(Fn(n - 1) + Fn(n - 2)); // when n>46 memory will  overflow
        }
```
###### 怎么判断两个平面是否相交 
法向量是否成比例或者点乘看夹角是否为0。


---
#### *...排序算法...*
---
![时间复杂度](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)
###### 冒泡排序
以排大数为例，通过与相邻元素的比较和交换来把大的数交换到后面，每一次只能排好一位。

```
for i := 0; i < len(arr)-1; i++ {
		for j := 0; j < len(arr)-1; j++ {
			if arr[j+1] < arr[j] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
```

###### 选择排序
和冒泡有点类似，不过是每次选择出一个最大或最小数放到最终位置上，每一趟只会交换一次。

```
for i := 0; i < len(arr)-1; i++ {
		min := i
		for j := i + 1; j < len(arr); j++ {
			if arr[j] < arr[min] {
				min = j
			}
		}
		if min != i {
			arr[i], arr[min] = arr[min], arr[i]
		}
	}
```

###### 插入排序
和冒泡、选择类似，每读取一个数就和已排好序的作比较，插入到合适的位置，他们的时间复杂度都是O(n^2)。
###### 快速排序（时间复杂度：最优O(nlog(n))；最差O(n^2)）
从数据中任选一个基数，然后从两端轮流比较，将数组分成两个子数组，左边的都比基数小，右边都比基数大，然后递归左右子数组。

```
func QuickSort(arr []int, left int, right int) {
	if left < right {
		midIdx := once(arr, left, right)
		QuickSort(arr, left, midIdx-1)
		QuickSort(arr, midIdx+1, right)
	}
}

//单次排序
func once(arr []int, left int, right int) int {
	mid := arr[left]
	for left < right {
		//右侧查找比基数小的，替换到左边基数的位置上
		for left < right && arr[right] > mid {
			right--
		}
		arr[left] = arr[right]
		//左侧查找比基数大的的，替换到右边上次结束的位置上
		for left < right && arr[left] < mid {
			left++
		}
		arr[right] = arr[left]
	}
	//结束时放到中间：left是最后计算的，且右侧right停止的地方都在左边有备份的
	arr[left] = mid
	return left
}
```
###### 归并排序（时间复杂度：O(nlog(n))）
递归拆分直到最小有序子序列，然后再递归合并。

```
func MergeSort(arr []int, left int, right int) {
		if left < right {
		mid := (left + right) / 2
		MergeSort(arr, left, mid)
		MergeSort(arr, mid+1, right)
		merge(arr, left, mid, right)
	}
}

//递归合并函数
func merge(arr []int, left int, mid int, right int) {
	resultArr := make([]int, right-left+1)
	//从最小的一个元素的子序列，合并时保证有序，逐步叠加，则都是有序的
	i, j, idx := left, mid+1, 0
	//两个有序序列合并
	for i <= mid && j <= right {
		if arr[i] < arr[j] {
			resultArr[idx] = arr[i]
			i++
		} else {
			resultArr[idx] = arr[j]
			j++
		}
		idx++

	}
	//左侧有剩余
	for ; i <= mid; i++ {
		resultArr[idx] = arr[i]
		idx++
	}
	//右侧有剩余
	for ; j <= right; j++ {
		resultArr[idx] = arr[j]
		idx++
	}
	idx = 0
	//拷贝到原数组中
	for _, v := range resultArr {
		arr[left+idx] = v
		idx++
	}
}
```
###### 堆排序
每一个节点，检查和其子节点的大小，不满足则呼唤，如此递归（或直接用循环）。在数组中，子节点分别是(2i+1、2i+2)。

- 建立初始堆，仅仅满足父节点都大于或小于子节点，但整体数据还不是有序的。
- 每次交换首尾两个元素，调整堆，得到一个最大或最小的数据，对剩下的数据继续交换调整。

```
public void HeapAdjust(int[] array, int parent, int length) {
    int temp = array[parent]; // temp保存当前父节点
    int child = 2 * parent + 1; // 先获得左孩子
 
    while (child < length) {
        // 选取子节点中较大的
        if (child + 1 < length && array[child] < array[child + 1]) {
            child++;
        }
 
        if (temp >= array[child])
            break;
 
        // 把孩子结点的值赋给父结点
        array[parent] = array[child];
 
        // 选取孩子结点的左孩子结点,继续向下筛选
        parent = child;
        child = 2 * child + 1;
    }
 
    array[parent] = temp;
}
 
public void heapSort(int[] list) {
    // 循环建立初始堆
    for (int i = list.length / 2; i >= 0; i--) {
        HeapAdjust(list, i, list.length - 1);
    }
 
    // 进行n-1次循环，完成排序
    for (int i = list.length - 1; i > 0; i--) {
        // 最后一个元素和第一元素进行交换
        int temp = list[i];
        list[i] = list[0];
        list[0] = temp;
 
        // 筛选 R[0] 结点，得到i-1个结点的堆
        HeapAdjust(list, 0, i);
    }
}
```


###### 桶排序
把n个数分成m个桶，基于某种映射函数，将数据映射到一个桶里，映射函数必须满足小的数要放到小的桶中，映射函数要根据数据的特点设置（如都是100以内的数，这映射函数可以为k/10），时间复杂度有两部分组成：n个数据的映射O(n)和所有的桶的排序复杂度之和，尽量减少桶内数据的数量是提高效率的唯一办法。

---
#### *...查找算法...*
---
###### 顺序查找：适用于线性表或链表，但数据量大的时候性能低
###### 折半查找（二分查找:O(logn)）
每次取中间值比较。为什么是二分呢，主要是简单，二分的思想非A即B，逻辑简单，也很符合现实中人的思维，但不是效率最高的。

```
递归版本
template<typename T>
int recurBiSearch(const vector<T> &vt, T key, int low, int up)
{
	if(low>up) return -1;
	int mid = (low+up)>>1;
	if (key < vt[mid])
	{
		return recurBiSearch(vt, key, low, mid-1);
	}
	else if (vt[mid] < key)
	{
		return recurBiSearch(vt, key, mid+1, up);
	}
	return mid;
}

非递归版本
template<typename T>
int iterBiSearch(vector<T> &vt, T key, int low, int up)
{
	int mid;
	while (low<=up)
	{
		mid = (low+up)>>1;
		if(key<vt[mid])
			up = mid - 1;
		else if(vt[mid]<key)
			low = mid + 1;
		else return mid;
	}
	return -1;
}
```

###### 插值查找
二分查找的进阶版：每次选取的位置与目标值的差值会影响下一次的位置，mid = low + (key - a[low])/(a[high]-a[low]) * (high - low)。
###### 裴波那契查找：黄金分割比的应用，复杂度O(logn)
但有要求，就是数据的数量为某个裴波那契数的值小1：F(K)-1。每次选取的位置为区间的黄金分割比处：mid=low+F(k)-1。
###### 二叉树查找:O(logn)
```
树节点：
struct TreeNode
{
    int key;
    TreeNode* left;
    TreeNode* right;
    TreeNode* parent;
};

递归版本：
TreeNode* treeSearch(TreeNode* root, int key)
{
    if(root == nullptr || key == root->key){
        return root;
    }

    if(key < root->key){
        return treeSearch(root->left, key);
    }else{
        return treeSearch(root->right, key);
    }
}

非递归（即迭代）：
TreeNode* iterativeTreeSearch(TreeNode* root, int key)
{
    while(root && key != root->key){
        if(key < root->key){
            root = root->left;
        }else{
            root = root->right;
        }
    }

    return root;
}

最大关键字与最小关键字：从树根开始沿着 left 孩子指针直到遇到一个 null，我们可以得到最小元素，反之可以得到最大元素。
TreeNode* treeMinimum(TreeNode* root)
{
    while(root->left){
        root = root->left;
    }

    return root;
}

```
###### 字符串比较函数
###### 100亿个整数，求最大的1万个数，并说出算法的时间复杂度算法
思路一：

在内存中维护一个大小为10000的最小堆，每次从文件读一个数，与最小堆的堆顶元素比较，若比堆顶元素大，则替换掉堆顶元素，然后调整堆。最后剩下的堆内元素即为最大的1万个数，算法复杂度为O(NlogN)。（实现：从文件读数据有讲究，如果每次只读一个数，效率太低，可以维护一个输入缓冲区，一次读取一大块数据到内存，用完了又从文件接着读，这样效率高很多，缓冲区的大小也有讲究，一般要设为4KB的整数倍，因为磁盘的块大小一般就是4KB）

思路二：快排，找出右侧大区间递归，知道大数区间数目达到。

思路三：分块，10000份，每份中查找出最大数。

###### 给定N张扑克牌和一个随机函数，设计一个洗牌算法
```
void shuffle(int cards[],int n)
{
    if(cards==NULL)
        return ;
 
    srand(time(0));
 
    for(int i=0;i<n-1;++i)
    {
        //保证每次第i位的值不会涉及到第i位以前
        int index=i+rand()%(n-i);
        int temp=cards[i];
        cards[i]=cards[index];
        cards[index]=temp;
    }
}

```
###### 如何等概率地从n个数中随机抽出m个数？上题中如果n的大小不确定（可以认为是⼀个数据流），如何做？
前m个元素都选上，当到第k（k>m)元素时,按照概率m/k的概率选中，并和已经选中的m个元素中随机一个进行替换。
###### 给定一个能够生成0,1两个数的等概率随机数生成器”，如何生成⼀个产生0,1,2,3的等概率随机数生成器?和上题类似，如何用rand7生成rand9?
将两个0,1随机生成器级联，每次产生两个数，则可能的结果有(0,0), (0,1), (1,0), (1,1)，分别映 射到0, 1, 2, 3即可;两个rand7可以产生49种可能，扔掉后面的4种，保留前45个，并平均分成9份，每次产生一个结果时，假如没落在对应区间中就扔掉，否则根据落在哪个区间判断是0--8中哪个
###### 给定100亿个整数，设计算法找到只出现一次的整数
使用hash将所有整数映射到1000个文件中，在每个文件中使用 bitmap，用两个bit表示出现次数，00表示没出现过，01表示出现过1次，10表示出现过多次，11舍弃，最后归并每个文件中出现只有1次的数即为所求。
###### 设计并实现一个LRU Cache
1. set(key,value)：如果key在hashmap中存在，则先重置对应的value值，然后获取对应的节点cur，将cur节点从链表删除，并移动到链表的头部；若果key在hashmap不存在，则新建一个节点，并将节点放到链表的头部。当Cache存满的时候，将链表最后一个节点删除即可。 

2. get(key)：如果key在hashmap中存在，则把对应的节点放到链表头部，并返回对应的value值；如果不存在，则返回-1。

###### 二叉搜索树的建立：中序，比节点小的放入左子树，大的放入右字树，递归。
>假如已知有n个人和m对好友关系（存于数字r）。如果两个人是直接或间接的好友（好友的好友的好友...），则认为他们属于同一个朋友圈，请写程序求出这n个人里一共有多少个朋友圈。假如：n = 5 ， m = 3 ， r = {{1 , 2} , {2 , 3} , {4 , 5}}，表示有5个人，1和2是好友，2和3是好友，4和5是好友，则1、2、3属于一个朋友圈，4、5属于另一个朋友圈，结果为2个朋友圈。

```
private int [] set=new int[1000]; //存放上级，如set[5]=3表示5的上级是3  
  
    public int find(int x){ //查看掌门人  
        int r;  
        r=x;  
        while(set[r]!=r){ //如果掌门人不是自己，一直向上查找  
            r=set[r];  
        }  
        return r;  
    }  
      
    public void join(int x,int y){ //让两个人做朋友  
        int fx=find(x); //找到到x的掌门  
        int fy=find(y); //找到y的掌门  
        if(fx!=fy) { //如果不是同一个人  
            set[fx]=fy;  
        }  
    }  
      
    public int friends(int n,int m,int [][] r){  
        int count=0,i;  
        for(i=1;i<=n;i++) //初始化并查集  
            set[i]=i;  
        for(i=0;i<m;i++)  
            join(r[i][0],r[i][1]);  
        for(i=1;i<=n;i++)  
            if(set[i]==i) count++;  
        return count;     
    } 
```

###### 深度优先搜索和广度优先搜索，时间复杂度为O(n2)
```
typedef double AdjMatrix[MaxVnum][MaxVnum];   //表示一个矩阵，用来存储顶点和边连接关系
typedef struct {
    int vexnum,arcnum;　　　　　　　　　　　　　　 //顶点的个数，边的个数
    AdjMatrix arcs;　　　　　　　　　　　　　　　　 //图的邻接矩阵
}Graph;

bool visited[MaxVnum];
void DFS(Graph G,int v)
{
    visited[v]= true; //从V开始访问，flag它
    printf("%d",v);    //打印出V
    for(int j=0;j<G.vexnum;j++) 
        if(G.arcs[v][j]==1&&visited[j]== false) //这里可以获得V未访问过的邻接点
            DFS(G,j); //递归调用，如果所有节点都被访问过，就回溯，而不再调用这里的DFS
}
//广度优先搜索需要借助队列将一个节点的子节点先处理
queue<int> Q;
for(int v=0;v<G.vexnum;v++)    
    {
        if(visited[v]==false)   //若该点没有访问
        {
            Q.push(v);　　　　//将其加入到队列中
            visited[v]=true;
            while (!Q.empty())　　//只要队列不空，遍历就没有结束
            {
                int t =Q.front();　　//取出对头元素
                Q.pop();
                printf(" %d ",t+1);  
                for(int j=0;j<G.vexnum;j++) //将其未访问过的邻接点加进入队列
                    if(G.arcs[t][j]==1&&visited[j]== false)
                    {
                        Q.push(j);
                        visited[j]=true; //在这里要设置true，因为这里该顶点我们已经加入到了队列，为了防止重复加入！
                    }
            }
        }
    }

```
###### 链表逆序：使用递归，先反转后面的节点
```
Node* reverse(Node *head)

{
	//如果链表为空或者链表中只有一个元素

	if(head==NULL || head->next==NULL)

		return head;

	else

	{

		Node* newhead=reverse(head->next);//先反转后面的链表

		head->next->next=head;//俩俩互换

		head->next=NULL;

		return newhead;//始终保持最后一个节点作为新的头结点

	}
}
```























